---
/**
 * MasterAnimation - Centralized GSAP animation controller
 * Implements Disney's 12 animation principles with brutalist aesthetic
 */
---

<script>
  import { gsap } from "gsap";
  import { ScrollTrigger } from "gsap/ScrollTrigger";

  gsap.registerPlugin(ScrollTrigger);

  // Store all triggers for cleanup
  const allTriggers: ScrollTrigger[] = [];

  // ============================================
  // EASING PRESETS - Brutalist Feel
  // ============================================
  const BRUTAL_EASE = "power4.out";
  const SMOOTH_EASE = "power3.out";
  const SNAP_EASE = "power2.out";
  const ELASTIC_EASE = "elastic.out(1, 0.5)";
  const EXPO_EASE = "expo.out";

  // ============================================
  // PRINCIPLE 1: SQUASH AND STRETCH
  // Used for letter bounces and hover effects
  // ============================================
  function initSquashAndStretch() {
    const letters = gsap.utils.toArray<HTMLElement>(".animate-squash");
    
    letters.forEach((letter) => {
      letter.addEventListener("mouseenter", () => {
        gsap.to(letter, {
          scaleY: 0.85,
          scaleX: 1.15,
          duration: 0.15,
          ease: "power2.out",
        });
      });
      
      letter.addEventListener("mouseleave", () => {
        gsap.to(letter, {
          scaleY: 1,
          scaleX: 1,
          duration: 0.4,
          ease: "elastic.out(1, 0.5)",
        });
      });
    });
  }

  // ============================================
  // PRINCIPLE 2: ANTICIPATION
  // Wind-up before main action
  // ============================================
  function initAnticipation() {
    const anticipateElements = gsap.utils.toArray<HTMLElement>(".animate-anticipate");
    
    anticipateElements.forEach((el) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el, 
        { y: 30, scaleY: 0.95 }, // Anticipation pose
        { y: 0, scaleY: 1, duration: 0.2, ease: "power2.in" }
      )
      .to(el, {
        y: -20,
        duration: 0.4,
        ease: BRUTAL_EASE,
      })
      .to(el, {
        y: 0,
        duration: 0.3,
        ease: "bounce.out",
      });
    });
  }

  // ============================================
  // PRINCIPLE 3: STAGING
  // Focus attention with blur/focus effects
  // ============================================
  function initStaging() {
    const stagedSections = gsap.utils.toArray<HTMLElement>(".animate-staging");
    
    stagedSections.forEach((section) => {
      const bg = section.querySelector(".staging-bg");
      const hero = section.querySelector(".staging-hero");
      
      if (bg && hero) {
        const trigger = ScrollTrigger.create({
          trigger: section,
          start: "top center",
          end: "bottom center",
          onUpdate: (self) => {
            const progress = self.progress;
            gsap.set(bg, { filter: `blur(${progress * 5}px)`, opacity: 0.6 + progress * 0.2 });
            gsap.set(hero, { scale: 1 + progress * 0.05 });
          },
        });
        allTriggers.push(trigger);
      }
    });
  }

  // ============================================
  // PRINCIPLE 4 & 5: STRAIGHT AHEAD / FOLLOW THROUGH
  // Overlapping action for staggered reveals
  // ============================================
  function initOverlappingReveals() {
    // Letters with follow-through
    const textContainers = gsap.utils.toArray<HTMLElement>(".animate-overlap");
    
    textContainers.forEach((container) => {
      const chars = container.querySelectorAll(".overlap-char");
      
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: container,
          start: "top 80%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      chars.forEach((char, i) => {
        // Main character
        tl.fromTo(char,
          { y: 100, opacity: 0, rotateX: -90 },
          { 
            y: 0, 
            opacity: 1, 
            rotateX: 0,
            duration: 0.8,
            ease: BRUTAL_EASE,
          },
          i * 0.03
        );
        
        // Follow-through shadow/delay effect
        const shadow = char.querySelector(".char-shadow");
        if (shadow) {
          tl.fromTo(shadow,
            { y: 20, opacity: 0 },
            { y: 0, opacity: 0.3, duration: 0.6, ease: SMOOTH_EASE },
            i * 0.03 + 0.1
          );
        }
      });
    });
  }

  // ============================================
  // PRINCIPLE 6: SLOW IN AND SLOW OUT
  // Refined easing for all scroll animations
  // ============================================
  function initSlowInOut() {
    const slowElements = gsap.utils.toArray<HTMLElement>(".animate-slow-ease");
    
    slowElements.forEach((el) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { y: 80, opacity: 0 },
        { 
          y: 0, 
          opacity: 1, 
          duration: 1.2,
          ease: "power2.inOut", // Slow in AND out
        }
      );
    });
  }

  // ============================================
  // PRINCIPLE 7: ARC
  // Arc motion paths for floating elements
  // ============================================
  function initArcMotion() {
    const arcElements = gsap.utils.toArray<HTMLElement>(".animate-arc");
    
    arcElements.forEach((el, i) => {
      // Continuous floating with arc
      gsap.to(el, {
        motionPath: {
          path: [
            { x: 0, y: 0 },
            { x: 30, y: -50 },
            { x: 60, y: 0 },
            { x: 30, y: 50 },
            { x: 0, y: 0 },
          ],
          curviness: 1.5,
        },
        duration: 8 + i * 2,
        ease: "sine.inOut",
        repeat: -1,
      });
    });
  }

  // ============================================
  // PRINCIPLE 8: SECONDARY ACTION
  // Main + supporting animations
  // ============================================
  function initSecondaryActions() {
    const primaryElements = gsap.utils.toArray<HTMLElement>(".animate-primary");
    
    primaryElements.forEach((el) => {
      const secondary = el.querySelectorAll(".animate-secondary");
      
      el.addEventListener("mouseenter", () => {
        // Primary action
        gsap.to(el, { scale: 1.02, duration: 0.3, ease: SNAP_EASE });
        
        // Secondary actions with slight delay
        secondary.forEach((sec, i) => {
          gsap.to(sec, {
            y: -5,
            rotation: (i % 2 === 0 ? 5 : -5),
            duration: 0.4,
            delay: i * 0.05,
            ease: ELASTIC_EASE,
          });
        });
      });
      
      el.addEventListener("mouseleave", () => {
        gsap.to(el, { scale: 1, duration: 0.3, ease: SNAP_EASE });
        secondary.forEach((sec) => {
          gsap.to(sec, { y: 0, rotation: 0, duration: 0.3, ease: SNAP_EASE });
        });
      });
    });
  }

  // ============================================
  // PRINCIPLE 9: TIMING
  // Varied durations for rhythm
  // ============================================
  function initTimingVariations() {
    // Fast elements
    gsap.utils.toArray<HTMLElement>(".animate-fast").forEach((el) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { x: -100, opacity: 0 },
        { x: 0, opacity: 1, duration: 0.4, ease: EXPO_EASE }
      );
    });
    
    // Slow elements
    gsap.utils.toArray<HTMLElement>(".animate-slow").forEach((el, i) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 90%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { y: 40, opacity: 0 },
        { y: 0, opacity: 1, duration: 1.5, delay: i * 0.2, ease: "sine.out" }
      );
    });
  }

  // ============================================
  // PRINCIPLE 10: EXAGGERATION
  // Push beyond realism for impact
  // ============================================
  function initExaggeration() {
    const exaggerateElements = gsap.utils.toArray<HTMLElement>(".animate-exaggerate");
    
    exaggerateElements.forEach((el) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 80%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { 
          scale: 0.5, 
          rotation: -15,
          opacity: 0,
        },
        { 
          scale: 1, 
          rotation: 0,
          opacity: 1,
          duration: 0.8,
          ease: "back.out(1.7)", // Exaggerated overshoot
        }
      );
    });
  }

  // ============================================
  // PRINCIPLE 11: SOLID DRAWING
  // 3D transforms and perspective
  // ============================================
  function initSolidDrawing() {
    const solidElements = gsap.utils.toArray<HTMLElement>(".animate-solid");
    
    solidElements.forEach((el) => {
      gsap.set(el, { transformPerspective: 1000 });
      
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { 
          rotationX: 45,
          rotationY: -15,
          z: -200,
          opacity: 0,
        },
        { 
          rotationX: 0,
          rotationY: 0,
          z: 0,
          opacity: 1,
          duration: 1,
          ease: BRUTAL_EASE,
        }
      );
    });
  }

  // ============================================
  // PRINCIPLE 12: APPEAL
  // Character and charm through animation
  // ============================================
  function initAppeal() {
    // Magnetic hover effect for interactive elements
    const magneticElements = gsap.utils.toArray<HTMLElement>(".animate-magnetic");
    
    magneticElements.forEach((el) => {
      el.addEventListener("mousemove", (e) => {
        const rect = el.getBoundingClientRect();
        const x = e.clientX - rect.left - rect.width / 2;
        const y = e.clientY - rect.top - rect.height / 2;
        
        gsap.to(el, {
          x: x * 0.3,
          y: y * 0.3,
          duration: 0.3,
          ease: "power2.out",
        });
      });
      
      el.addEventListener("mouseleave", () => {
        gsap.to(el, {
          x: 0,
          y: 0,
          duration: 0.5,
          ease: "elastic.out(1, 0.3)",
        });
      });
    });
    
    // Breathing/pulse animation for emphasis
    const breatheElements = gsap.utils.toArray<HTMLElement>(".animate-breathe");
    breatheElements.forEach((el) => {
      gsap.to(el, {
        scale: 1.02,
        duration: 2,
        ease: "sine.inOut",
        yoyo: true,
        repeat: -1,
      });
    });
  }

  // ============================================
  // ENHANCED HERO ANIMATIONS
  // ============================================
  function initHeroAnimations() {
    const heroLetters = gsap.utils.toArray<HTMLElement>(".hero-letter");
    
    // Initial drop animation with stagger
    heroLetters.forEach((letter, i) => {
      const delay = 0.5 + i * 0.08;
      
      gsap.fromTo(letter,
        { 
          y: -200, 
          opacity: 0,
          rotateX: -90,
          transformOrigin: "center bottom",
        },
        { 
          y: 0, 
          opacity: 1,
          rotateX: 0,
          duration: 1.2,
          delay: delay,
          ease: "bounce.out", // Bounce on landing
        }
      );
    });
    
    // Scroll-based parallax for hero
    const heroSection = document.getElementById("hero");
    if (heroSection) {
      const trigger = ScrollTrigger.create({
        trigger: heroSection,
        start: "top top",
        end: "bottom top",
        scrub: 1,
        onUpdate: (self) => {
          const progress = self.progress;
          
          heroLetters.forEach((letter, i) => {
            const speed = 0.3 + (i % 3) * 0.1;
            gsap.set(letter, { y: progress * 100 * speed });
          });
        },
      });
      allTriggers.push(trigger);
    }
  }

  // ============================================
  // ENHANCED SCROLL REVEALS
  // ============================================
  function initScrollReveals() {
    // Line draw animation
    const drawLines = gsap.utils.toArray<HTMLElement>(".animate-draw-line");
    drawLines.forEach((line) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: line,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(line,
        { scaleX: 0, transformOrigin: "left center" },
        { scaleX: 1, duration: 0.8, ease: EXPO_EASE }
      );
    });
    
    // Text reveal with mask
    const textReveals = gsap.utils.toArray<HTMLElement>(".animate-text-reveal");
    textReveals.forEach((el) => {
      const text = el.textContent || "";
      el.innerHTML = text
        .split("")
        .map((char) => 
          `<span class="inline-block overflow-hidden"><span class="reveal-char inline-block">${char === " " ? "&nbsp;" : char}</span></span>`
        )
        .join("");
      
      const chars = el.querySelectorAll(".reveal-char");
      
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(chars,
        { y: "100%", rotateX: -90 },
        { 
          y: "0%", 
          rotateX: 0,
          duration: 0.6,
          stagger: 0.02,
          ease: BRUTAL_EASE,
        }
      );
    });
    
    // Slide reveals
    const slideLeft = gsap.utils.toArray<HTMLElement>(".animate-slide-left");
    slideLeft.forEach((el) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { x: -100, opacity: 0 },
        { x: 0, opacity: 1, duration: 0.8, ease: BRUTAL_EASE }
      );
    });
    
    const slideRight = gsap.utils.toArray<HTMLElement>(".animate-slide-right");
    slideRight.forEach((el) => {
      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: "top 85%",
          toggleActions: "play none none reverse",
        },
      });
      
      if (tl.scrollTrigger) allTriggers.push(tl.scrollTrigger);

      tl.fromTo(el,
        { x: 100, opacity: 0 },
        { x: 0, opacity: 1, duration: 0.8, ease: BRUTAL_EASE }
      );
    });
  }

  // ============================================
  // SMOOTH SCROLL ENHANCEMENT
  // ============================================
  function initSmoothScroll() {
    // Smooth scroll to anchors
    document.querySelectorAll('a[href^="#"]').forEach((anchor) => {
      anchor.addEventListener("click", (e) => {
        const href = anchor.getAttribute("href");
        if (!href || href === "#") return;
        
        const target = document.querySelector(href);
        if (target) {
          e.preventDefault();
          
          gsap.to(window, {
            scrollTo: { y: target, offsetY: 50 },
            duration: 1.2,
            ease: "power3.inOut",
          });
        }
      });
    });
    
    // Parallax images
    const parallaxImages = gsap.utils.toArray<HTMLElement>(".animate-parallax");
    parallaxImages.forEach((img) => {
      const trigger = ScrollTrigger.create({
        trigger: img,
        start: "top bottom",
        end: "bottom top",
        scrub: 1,
        onUpdate: (self) => {
          gsap.set(img, { y: self.progress * 100 - 50 });
        },
      });
      allTriggers.push(trigger);
    });
  }

  // ============================================
  // INITIALIZE ALL
  // ============================================
  function initAll() {
    initSquashAndStretch();
    initAnticipation();
    initStaging();
    initOverlappingReveals();
    initSlowInOut();
    initArcMotion();
    initSecondaryActions();
    initTimingVariations();
    initExaggeration();
    initSolidDrawing();
    initAppeal();
    initHeroAnimations();
    initScrollReveals();
    initSmoothScroll();
    
    // Refresh ScrollTrigger after all animations are set up
    ScrollTrigger.refresh();
  }

  // Run on DOM ready
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initAll);
  } else {
    initAll();
  }

  // Astro page transitions
  document.addEventListener("astro:page-load", () => {
    // Clean up old triggers
    allTriggers.forEach((trigger) => trigger.kill());
    allTriggers.length = 0;
    // Re-init
    initAll();
  });

  // Cleanup on page unload
  window.addEventListener("beforeunload", () => {
    allTriggers.forEach((trigger) => trigger.kill());
  });
</script>

<style is:global>
  /* Animation utility classes */
  .animate-squash,
  .animate-anticipate,
  .animate-overlap,
  .animate-slow-ease,
  .animate-arc,
  .animate-primary,
  .animate-fast,
  .animate-slow,
  .animate-exaggerate,
  .animate-solid,
  .animate-magnetic,
  .animate-breathe,
  .animate-slide-left,
  .animate-slide-right,
  .animate-text-reveal,
  .animate-draw-line,
  .animate-parallax {
    will-change: transform, opacity;
  }
  
  /* Ensure 3D transforms work */
  .animate-solid {
    transform-style: preserve-3d;
  }
  
  /* Hide elements before animation */
  .animate-anticipate,
  .animate-overlap .overlap-char,
  .animate-slow-ease,
  .animate-exaggerate,
  .animate-solid,
  .animate-slide-left,
  .animate-slide-right {
    opacity: 0;
  }
</style>
