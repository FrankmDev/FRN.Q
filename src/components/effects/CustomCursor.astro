---
/**
 * CustomCursor - Interactive cursor with hover states and difference blend mode
 * Client-side only component
 */
---

<div
    id="custom-cursor"
    class="fixed top-0 left-0 z-[9999] pointer-events-none hidden md:flex items-center justify-center"
    style="width: 20px; height: 20px; border-radius: 50%; background-color: white; mix-blend-mode: difference; opacity: 0;"
    aria-hidden="true"
>
    <span
        id="cursor-label"
        class="font-mono text-black text-[0.6rem] tracking-[0.25em] uppercase font-bold opacity-0 whitespace-nowrap"
        style="mix-blend-mode: difference; transition: opacity 0.3s ease;"
    ></span>
</div>

<style is:global>
    /* Cursor styles */
    #custom-cursor {
        border-radius: 50%;
        transition:
            width 0.4s cubic-bezier(0.16, 1, 0.3, 1),
            height 0.4s cubic-bezier(0.16, 1, 0.3, 1),
            opacity 0.3s ease,
            background-color 0.3s ease,
            border 0.3s ease;
        will-change: transform;
    }

    #custom-cursor.is-expanded {
        width: 100px !important;
        height: 100px !important;
        border: 2px solid white;
        background-color: transparent;
    }
    
    #custom-cursor.is-expanded #cursor-label {
        font-size: 0.7rem;
        letter-spacing: 0.3em;
    }

    #custom-cursor.is-hidden {
        opacity: 0 !important;
    }

    #cursor-label.is-visible {
        opacity: 1;
    }

    /* Effect for letters - cursor expands but letters don't change color */
</style>

<style>
    #custom-cursor {
        border-radius: 50%;
        transition:
            width 0.4s cubic-bezier(0.16, 1, 0.3, 1),
            height 0.4s cubic-bezier(0.16, 1, 0.3, 1),
            opacity 0.3s ease,
            background-color 0.3s ease,
            border 0.3s ease;
        will-change: transform;
    }

    #custom-cursor.is-expanded {
        width: 100px !important;
        height: 100px !important;
        border: 2px solid white;
        background-color: transparent;
    }

    #custom-cursor.is-hidden {
        opacity: 0 !important;
    }

    #cursor-label.is-visible {
        opacity: 1;
    }
</style>

<script>
    (function initCustomCursor() {
        const cursor = document.getElementById("custom-cursor");
        const cursorLabel = document.getElementById("cursor-label");

        if (!cursor) return;

        // Estado del cursor
        let posX = 0,
            posY = 0;
        let targetX = 0,
            targetY = 0;
        let isExpanded = false;
        let currentLabel = "";
        let rafId = null;
        let isActive = true;
        let hasMouseMoved = false;
        let isOverRed: boolean = false;

        // Utilidad: lerp para suavizado
        const lerp = (a, number, t) => a + (number - a) * t;

        // Detectar si el cursor está sobre un elemento rojo con texto oscuro
        const checkRedCollision = (cursorX: number, cursorY: number) => {
            const element = document.elementFromPoint(cursorX, cursorY);
            if (!element) return { isRed: false, hasDarkText: false };
            
            // Detectar colores rojos (rgb con R alto y G,B bajos)
            const isRed = (colorStr: string) => {
                const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (!match) return false;
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                // Es rojo si R > 200 y G,B < 100
                return r > 200 && g < 100 && b < 100;
            };
            
            // Detectar si el color es oscuro (texto negro)
            const isDark = (colorStr: string) => {
                const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
                if (!match) return false;
                const r = parseInt(match[1]);
                const g = parseInt(match[2]);
                const b = parseInt(match[3]);
                // Es oscuro si todos los valores son bajos (< 50)
                return r < 50 && g < 50 && b < 50;
            };
            
            // Verificar elemento y padres
            let parent = element;
            let foundRedBg = false;
            let foundDarkText = false;
            
            for (let i = 0; i < 3; i++) {
                if (!parent) break;
                const parentStyle = window.getComputedStyle(parent);
                
                if (isRed(parentStyle.backgroundColor)) {
                    foundRedBg = true;
                }
                if (isDark(parentStyle.color)) {
                    foundDarkText = true;
                }
                
                parent = parent.parentElement as Element;
            }
            
            return { isRed: foundRedBg, hasDarkText: foundDarkText };
        };
        
        // Loop de animación
        let frameCount = 0;
        const animate = () => {
            if (!isActive) return;

            posX = lerp(posX, targetX, 0.15);
            posY = lerp(posY, targetY, 0.15);

            cursor.style.transform = `translate(${posX}px, ${posY}px) translate(-50%, -50%)`;
            
            // Check collision cada 6 frames (10 veces por segundo) para mejor rendimiento
            frameCount++;
            if (frameCount % 6 === 0) {
                checkLetterCollision(posX, posY);
                
                // Check red collision cada 6 frames también
                const redCheck = checkRedCollision(posX, posY);
                const isOverRedNow = redCheck.isRed;
                const hasDarkText = redCheck.hasDarkText;
                
                if (isOverRedNow !== isOverRed) {
                    isOverRed = isOverRedNow;
                    
                    if (isOverRed) {
                        // Sobre fondo rojo
                        if (hasDarkText) {
                            // Texto oscuro (negro) → cursor BLANCO para contraste
                            cursor.style.backgroundColor = 'white';
                            cursor.style.mixBlendMode = 'normal';
                            if (cursorLabel) cursorLabel.style.color = 'black';
                        } else {
                            // Texto claro → cursor NEGRO
                            cursor.style.backgroundColor = 'black';
                            cursor.style.mixBlendMode = 'normal';
                            if (cursorLabel) cursorLabel.style.color = 'white';
                        }
                    } else {
                        // No sobre rojo: cursor blanco con difference
                        cursor.style.backgroundColor = 'white';
                        cursor.style.mixBlendMode = 'difference';
                        if (cursorLabel) cursorLabel.style.color = 'black';
                    }
                }
            }
            
            rafId = requestAnimationFrame(animate);
        };

        // Check if cursor is near letters and expand cursor (like project titles)
        let isNearLetter = false;
        let cachedLetters = null;
        let lastCheckTime = 0;
        
        const checkLetterCollision = (cursorX, cursorY) => {
            const now = Date.now();
            // Cache letters por 500ms para evitar querySelectorAll constante
            if (!cachedLetters || now - lastCheckTime > 500) {
                cachedLetters = document.querySelectorAll('.hero-letter, .contact-letter, .lab-letter');
                lastCheckTime = now;
            }
            
            const cursorRadius = isExpanded ? 40 : 30;
            let nearLetter = false;
            
            // Solo revisar las primeras 10 letras para mejor rendimiento
            const lettersToCheck = Math.min(cachedLetters.length, 10);
            for (let i = 0; i < lettersToCheck; i++) {
                const letter = cachedLetters[i];
                const rect = letter.getBoundingClientRect();
                const letterCenterX = rect.left + rect.width / 2;
                const letterCenterY = rect.top + rect.height / 2;
                
                const distance = Math.sqrt(
                    Math.pow(cursorX - letterCenterX, 2) + 
                    Math.pow(cursorY - letterCenterY, 2)
                );
                
                // If cursor is close to letter, mark as near
                if (distance < cursorRadius + Math.max(rect.width, rect.height) / 2 + 20) {
                    nearLetter = true;
                    break;
                }
            }
            
            // Expand cursor when near letters (like hovering project titles)
            if (nearLetter && !isNearLetter) {
                isNearLetter = true;
                cursor.classList.add('is-expanded');
                if (cursorLabel) {
                    cursorLabel.classList.remove('is-visible');
                    cursorLabel.textContent = '';
                }
            } else if (!nearLetter && isNearLetter) {
                isNearLetter = false;
                cursor.classList.remove('is-expanded');
            }
        };

        // Mostrar cursor inicialmente en el centro de la pantalla
        const initCursor = () => {
            targetX = window.innerWidth / 2;
            targetY = window.innerHeight / 2;
            posX = targetX;
            posY = targetY;
            cursor.style.transform = `translate(${posX}px, ${posY}px) translate(-50%, -50%)`;
            cursor.style.opacity = "1";
            if (!rafId) {
                rafId = requestAnimationFrame(animate);
            }
        };

        // Handlers de eventos
        const handleMouseMove = (e) => {
            targetX = e.clientX;
            targetY = e.clientY;
            hasMouseMoved = true;

            if (cursor.classList.contains("is-hidden")) {
                cursor.classList.remove("is-hidden");
            }
        };

        const handleMouseOver = (e) => {
            const el = e.target;
            if (!el) return;

            const cursorAttr = el.closest("[data-cursor]");
            const isLink = el.closest(
                'a, button, [role="button"], input, textarea, select, label',
            );

            if (cursorAttr) {
                const label = cursorAttr.dataset.cursor || "VIEW";
                if (label !== currentLabel && cursorLabel) {
                    cursorLabel.textContent = label;
                    cursorLabel.classList.add("is-visible");
                    currentLabel = label;
                }
                if (!isExpanded) {
                    cursor.classList.add("is-expanded");
                    isExpanded = true;
                }
            } else if (isLink) {
                if (cursorLabel) {
                    cursorLabel.classList.remove("is-visible");
                    cursorLabel.textContent = "";
                }
                currentLabel = "";
                if (!isExpanded) {
                    cursor.classList.add("is-expanded");
                    isExpanded = true;
                }
            } else {
                if (cursorLabel) {
                    cursorLabel.classList.remove("is-visible");
                    cursorLabel.textContent = "";
                }
                currentLabel = "";
                if (isExpanded) {
                    cursor.classList.remove("is-expanded");
                    isExpanded = false;
                }
            }
        };

        const handleMouseLeave = () => {
            cursor.classList.add("is-hidden");
        };

        const handleMouseEnter = () => {
            cursor.classList.remove("is-hidden");
            cursor.style.opacity = "1";
        };

        const handleVisibilityChange = () => {
            if (document.hidden) {
                isActive = false;
                if (rafId) cancelAnimationFrame(rafId);
            } else {
                isActive = true;
                rafId = requestAnimationFrame(animate);
            }
        };

        // Limpiar listeners anteriores si existen
        const cleanup = () => {
            if (rafId) cancelAnimationFrame(rafId);
            rafId = null;
            window.removeEventListener("mousemove", handleMouseMove);
            document.removeEventListener("mouseover", handleMouseOver);
            document.removeEventListener("mouseleave", handleMouseLeave);
            document.removeEventListener("mouseenter", handleMouseEnter);
            document.removeEventListener(
                "visibilitychange",
                handleVisibilityChange,
            );
        };

        // Limpiar antes de inicializar
        cleanup();

        // Inicializar
        initCursor();

        window.addEventListener("mousemove", handleMouseMove, {
            passive: true,
        });
        document.addEventListener("mouseover", handleMouseOver, {
            passive: true,
        });
        document.addEventListener("mouseleave", handleMouseLeave);
        document.addEventListener("mouseenter", handleMouseEnter);
        document.addEventListener("visibilitychange", handleVisibilityChange);

        // Iniciar animación
        isActive = true;
        rafId = requestAnimationFrame(animate);

        // Hacer cleanup disponible globalmente
        window.__cleanupCustomCursor = cleanup;
    })();
</script>
